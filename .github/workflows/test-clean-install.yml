name: Test Clean Installation

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test-clean-install:
    name: Clean Install Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect expected database versions
        id: versions
        run: |
          # Extract PostgreSQL version from docker-compose.yml
          PG_IMAGE=$(grep -A 1 "postgres:" docker-compose.yml | grep "image:" | sed 's/.*postgres:\([^-]*\).*/\1/')
          echo "Expected PostgreSQL version: $PG_IMAGE"
          echo "postgres_version=$PG_IMAGE" >> $GITHUB_OUTPUT
          
          # Extract Redis version from docker-compose.yml
          REDIS_IMAGE=$(grep -A 1 "redis:" docker-compose.yml | grep "image:" | sed 's/.*redis:\([^-]*\).*/\1/')
          echo "Expected Redis version: $REDIS_IMAGE"
          echo "redis_version=$REDIS_IMAGE" >> $GITHUB_OUTPUT

      - name: Create test .env file
        run: |
          # Generate secrets first
          ENCRYPTION_KEY=$(openssl rand -base64 32)
          JWT_SECRET=$(openssl rand -base64 64)
          JWT_REFRESH_SECRET=$(openssl rand -base64 64)
          SHARE_TOKEN_SECRET=$(openssl rand -base64 64)
          
          # Create .env file with proper escaping
          cat > .env << 'EOF'
          # Database Configuration
          POSTGRES_USER=vitransfer
          POSTGRES_PASSWORD=test_postgres_password
          POSTGRES_DB=vitransfer
          
          # Redis Configuration
          REDIS_PASSWORD=test_redis_password
          
          # Application Configuration
          APP_PORT=4321
          TZ=UTC
          PUID=1000
          PGID=1000
          
          # Admin Account
          ADMIN_EMAIL=admin@test.local
          ADMIN_PASSWORD=TestPassword123!
          ADMIN_NAME=Test Admin
          
          # Application URL
          NEXT_PUBLIC_APP_URL=http://localhost:4321
          
          # HTTPS
          HTTPS_ENABLED=false
          EOF
          
          # Append secrets separately with quotes to handle special characters
          echo "ENCRYPTION_KEY=\"$ENCRYPTION_KEY\"" >> .env
          echo "JWT_SECRET=\"$JWT_SECRET\"" >> .env
          echo "JWT_REFRESH_SECRET=\"$JWT_REFRESH_SECRET\"" >> .env
          echo "SHARE_TOKEN_SECRET=\"$SHARE_TOKEN_SECRET\"" >> .env

      - name: Start services with docker-compose
        run: |
          docker compose up -d
          echo "Waiting for services to be healthy..."
          sleep 30

      - name: Verify PostgreSQL version
        run: |
          EXPECTED_VERSION="${{ steps.versions.outputs.postgres_version }}"
          PG_FULL_VERSION=$(docker exec vitransfer-postgres psql --version | grep -oP '\d+\.\d+')
          PG_MAJOR_VERSION=$(echo "$PG_FULL_VERSION" | cut -d'.' -f1)
          echo "PostgreSQL version: $PG_FULL_VERSION (expected major: $EXPECTED_VERSION)"
          
          if [[ "$PG_MAJOR_VERSION" != "$EXPECTED_VERSION" ]]; then
            echo "[ERROR] Expected PostgreSQL major version $EXPECTED_VERSION, got $PG_MAJOR_VERSION (full: $PG_FULL_VERSION)"
            exit 1
          fi
          echo "[OK] PostgreSQL $PG_MAJOR_VERSION.x verified (full version: $PG_FULL_VERSION)"

      - name: Verify Redis version
        run: |
          EXPECTED_VERSION="${{ steps.versions.outputs.redis_version }}"
          REDIS_VERSION=$(docker exec vitransfer-redis redis-server --version | grep -oP 'v=\K[0-9]+\.[0-9]+')
          echo "Redis version: $REDIS_VERSION (expected: $EXPECTED_VERSION)"
          
          REDIS_MAJOR=$(echo $REDIS_VERSION | cut -d. -f1)
          EXPECTED_MAJOR=$(echo $EXPECTED_VERSION | cut -d. -f1)
          
          if [[ "$REDIS_MAJOR" != "$EXPECTED_MAJOR" ]]; then
            echo "[ERROR] Expected Redis $EXPECTED_MAJOR.x, got $REDIS_VERSION"
            exit 1
          fi
          echo "[OK] Redis $REDIS_MAJOR.x verified"

      - name: Check container health
        run: |
          echo "Checking container statuses..."
          docker compose ps
          
          # Check if all containers are healthy
          APP_HEALTH=$(docker inspect vitransfer-app --format='{{.State.Health.Status}}')
          POSTGRES_HEALTH=$(docker inspect vitransfer-postgres --format='{{.State.Health.Status}}')
          REDIS_HEALTH=$(docker inspect vitransfer-redis --format='{{.State.Health.Status}}')
          WORKER_HEALTH=$(docker inspect vitransfer-worker --format='{{.State.Health.Status}}')
          
          echo "App health: $APP_HEALTH"
          echo "PostgreSQL health: $POSTGRES_HEALTH"
          echo "Redis health: $REDIS_HEALTH"
          echo "Worker health: $WORKER_HEALTH"
          
          if [[ "$APP_HEALTH" != "healthy" ]] || \
             [[ "$POSTGRES_HEALTH" != "healthy" ]] || \
             [[ "$REDIS_HEALTH" != "healthy" ]] || \
             [[ "$WORKER_HEALTH" != "healthy" ]]; then
            echo "[ERROR] One or more containers are not healthy"
            docker compose logs
            exit 1
          fi
          echo "[OK] All containers are healthy"

      - name: Test database connection
        run: |
          echo "Testing PostgreSQL connection..."
          docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -c "SELECT version();"
          echo "[OK] Database connection successful"

      - name: Test Redis connection
        run: |
          echo "Testing Redis connection..."
          docker exec vitransfer-redis redis-cli -a test_redis_password --no-auth-warning ping
          echo "[OK] Redis connection successful"

      - name: Verify migrations ran
        run: |
          echo "Checking database migrations..."
          TABLES=$(docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public';")
          echo "Number of tables: $TABLES"
          if [[ $TABLES -lt 5 ]]; then
            echo "[ERROR] Expected at least 5 tables, found $TABLES"
            exit 1
          fi
          echo "[OK] Migrations completed successfully"

      - name: Test API health endpoint
        run: |
          echo "Testing health endpoint..."
          RESPONSE=$(curl -s http://localhost:4321/api/health)
          echo "Response: $RESPONSE"
          if [[ "$RESPONSE" != *"ok"* ]]; then
            echo "[ERROR] Health check failed"
            exit 1
          fi
          echo "[OK] API health check passed"

      - name: Test admin login
        run: |
          echo "Testing admin login..."
          LOGIN_RESPONSE=$(curl -s -X POST http://localhost:4321/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@test.local","password":"TestPassword123!"}')
          echo "Login response: $LOGIN_RESPONSE"
          if [[ "$LOGIN_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Admin login failed"
            echo "$LOGIN_RESPONSE"
            exit 1
          fi
          echo "[OK] Admin login successful"
          
          # Extract accessToken from the tokens object in the response
          AUTH_TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"accessToken":"[^"]*"' | head -1 | sed 's/"accessToken":"//;s/"$//')
          if [[ -z "$AUTH_TOKEN" ]]; then
            echo "[ERROR] Failed to extract access token from login response"
            echo "Full response: $LOGIN_RESPONSE"
            exit 1
          fi
          echo "$AUTH_TOKEN" > /tmp/auth_token.txt
          echo "Token extracted successfully (length: ${#AUTH_TOKEN})"

      - name: Test API endpoints
        run: |
          echo "Testing additional API endpoints..."
          AUTH_TOKEN=$(cat /tmp/auth_token.txt)
          
          # Test session endpoint
          echo "Testing session endpoint..."
          SESSION_RESPONSE=$(curl -s http://localhost:4321/api/auth/session \
            -H "Authorization: Bearer $AUTH_TOKEN")
          echo "Session response: $SESSION_RESPONSE"
          if [[ "$SESSION_RESPONSE" != *"admin@test.local"* ]] || [[ "$SESSION_RESPONSE" == *'"authenticated":false'* ]]; then
            echo "[ERROR] Session endpoint failed"
            echo "Full session response: $SESSION_RESPONSE"
            exit 1
          fi
          echo "[OK] Session endpoint working"
          
          # Test projects list endpoint
          echo "Testing projects list..."
          PROJECTS_RESPONSE=$(curl -s http://localhost:4321/api/projects \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$PROJECTS_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Projects endpoint failed"
            echo "$PROJECTS_RESPONSE"
            exit 1
          fi
          echo "[OK] Projects endpoint working"
          
          # Test users list endpoint
          echo "Testing users list..."
          USERS_RESPONSE=$(curl -s http://localhost:4321/api/users \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$USERS_RESPONSE" == *"error"* ]] || [[ "$USERS_RESPONSE" != *"admin@test.local"* ]]; then
            echo "[ERROR] Users endpoint failed"
            echo "$USERS_RESPONSE"
            exit 1
          fi
          echo "[OK] Users endpoint working"
          
          # Test settings endpoint
          echo "Testing settings endpoint..."
          SETTINGS_RESPONSE=$(curl -s http://localhost:4321/api/settings \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$SETTINGS_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Settings endpoint failed"
            echo "$SETTINGS_RESPONSE"
            exit 1
          fi
          echo "[OK] Settings endpoint working"
          
          # Test analytics endpoint
          echo "Testing analytics endpoint..."
          ANALYTICS_RESPONSE=$(curl -s http://localhost:4321/api/analytics \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$ANALYTICS_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Analytics endpoint failed"
            echo "$ANALYTICS_RESPONSE"
            exit 1
          fi
          echo "[OK] Analytics endpoint working"

      - name: Test project creation
        run: |
          echo "Testing project creation..."
          AUTH_TOKEN=$(cat /tmp/auth_token.txt)
          
          CREATE_PROJECT=$(curl -s -X POST http://localhost:4321/api/projects \
            -H "Authorization: Bearer $AUTH_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "CI Test Project",
              "description": "Automated test project",
              "recipientName": "Test Client",
              "recipientEmail": "client@test.local",
              "sharePassword": "TestPass123",
              "authMode": "PASSWORD"
            }')
          
          if [[ "$CREATE_PROJECT" == *"error"* ]]; then
            echo "[ERROR] Project creation failed"
            echo "$CREATE_PROJECT"
            exit 1
          fi
          
          PROJECT_ID=$(echo "$CREATE_PROJECT" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"$//')
          echo "Project created with ID: $PROJECT_ID"
          echo "$PROJECT_ID" > /tmp/test_project_id.txt
          echo "[OK] Project creation successful"

      - name: Check worker logs
        run: |
          echo "Checking worker initialization..."
          docker logs vitransfer-worker --tail 50
          
          WORKER_LOGS=$(docker logs vitransfer-worker 2>&1)
          if [[ "$WORKER_LOGS" != *"Video processing worker started"* ]]; then
            echo "[ERROR] Worker did not start properly"
            exit 1
          fi
          echo "[OK] Worker started successfully"

      - name: Generate test summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # Production Clean Install Test Results
          
          ## Test Configuration
          - **Docker Image**: `crypt010/vitransfer:latest`
          - **PostgreSQL**: `${{ steps.versions.outputs.postgres_version }}`
          - **Redis**: `${{ steps.versions.outputs.redis_version }}`
          - **Branch**: `${{ github.ref_name }}`
          - **Commit**: `${{ github.sha }}`
          
          ## Test Results
          
          | Test | Status |
          |------|--------|
          | Container Health | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | PostgreSQL Connection | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Redis Connection | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Database Migrations | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | API Health Endpoint | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Admin Login | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Session API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Projects API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Users API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Settings API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Analytics API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Project Creation | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Worker Initialization | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          
          EOF

      - name: Show application logs on failure
        if: failure()
        run: |
          echo "=== Application Logs ==="
          docker logs vitransfer-app --tail 100
          echo ""
          echo "=== PostgreSQL Logs ==="
          docker logs vitransfer-postgres --tail 50
          echo ""
          echo "=== Redis Logs ==="
          docker logs vitransfer-redis --tail 50
          echo ""
          echo "=== Worker Logs ==="
          docker logs vitransfer-worker --tail 50

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
          rm .env
