name: Test Version Upgrade

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      from_version:
        description: 'Upgrade from version (leave empty for auto-detect previous version)'
        required: false
        default: ''
      to_version:
        description: 'Upgrade to version (latest, dev, or specific tag)'
        required: false
        default: 'latest'

jobs:
  test-upgrade:
    name: Upgrade Test (Auto-detect â†’ ${{ github.event.inputs.to_version || 'latest' }})
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine versions for upgrade test
        id: versions
        run: |
          # Read current version from VERSION file
          CURRENT_VERSION=$(cat VERSION | tr -d '\n\r')
          echo "Current version: $CURRENT_VERSION"
          
          # Determine FROM version
          if [[ -n "${{ github.event.inputs.from_version }}" ]]; then
            FROM_VERSION="${{ github.event.inputs.from_version }}"
            echo "Using manually specified from_version: $FROM_VERSION"
          else
            # Auto-detect: Use previous minor version
            # Extract major.minor.patch
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            # Calculate previous version (decrement patch)
            if [[ $PATCH -gt 0 ]]; then
              PREV_PATCH=$((PATCH - 1))
              FROM_VERSION="${MAJOR}.${MINOR}.${PREV_PATCH}"
            else
              # If patch is 0, go back a minor version
              if [[ $MINOR -gt 0 ]]; then
                PREV_MINOR=$((MINOR - 1))
                FROM_VERSION="${MAJOR}.${PREV_MINOR}.0"
              else
                # Fallback to current version if can't determine
                FROM_VERSION="$CURRENT_VERSION"
              fi
            fi
            echo "Auto-detected from_version: $FROM_VERSION"
          fi
          
          # Determine TO version
          TO_VERSION="${{ github.event.inputs.to_version || 'latest' }}"
          echo "Upgrade to_version: $TO_VERSION"
          
          # Export for later steps
          echo "from_version=$FROM_VERSION" >> $GITHUB_OUTPUT
          echo "to_version=$TO_VERSION" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Create test .env file
        run: |
          # Generate secrets first
          ENCRYPTION_KEY=$(openssl rand -base64 32)
          JWT_SECRET=$(openssl rand -base64 64)
          JWT_REFRESH_SECRET=$(openssl rand -base64 64)
          SHARE_TOKEN_SECRET=$(openssl rand -base64 64)
          
          # Create .env file with proper escaping
          cat > .env << 'EOF'
          # Database Configuration
          POSTGRES_USER=vitransfer
          POSTGRES_PASSWORD=test_postgres_password
          POSTGRES_DB=vitransfer
          
          # Redis Configuration
          REDIS_PASSWORD=test_redis_password
          
          # Application Configuration
          APP_PORT=4321
          TZ=UTC
          PUID=1000
          PGID=1000
          
          # Admin Account
          ADMIN_EMAIL=admin@test.local
          ADMIN_PASSWORD=TestPassword123!
          ADMIN_NAME=Test Admin
          
          # Application URL
          NEXT_PUBLIC_APP_URL=http://localhost:4321
          
          # HTTPS
          HTTPS_ENABLED=false
          EOF
          
          # Append secrets separately with quotes to handle special characters
          echo "ENCRYPTION_KEY=\"$ENCRYPTION_KEY\"" >> .env
          echo "JWT_SECRET=\"$JWT_SECRET\"" >> .env
          echo "JWT_REFRESH_SECRET=\"$JWT_REFRESH_SECRET\"" >> .env
          echo "SHARE_TOKEN_SECRET=\"$SHARE_TOKEN_SECRET\"" >> .env

      - name: Deploy old version
        run: |
          FROM_VERSION="${{ steps.versions.outputs.from_version }}"
          echo "[DEPLOY] Deploying version $FROM_VERSION..."
          
          # Backup original compose file
          cp docker-compose.yml docker-compose.yml.new
          
          # Modify compose to use old version
          sed -i "s/image: crypt010\/vitransfer:latest/image: crypt010\/vitransfer:$FROM_VERSION/g" docker-compose.yml
          
          # Start old version
          docker compose up -d
          
          echo "[WAIT] Waiting for old version to be ready..."
          sleep 40
          
          # Verify old version is running
          docker compose ps

      - name: Verify old version started
        run: |
          echo "Checking if old version is healthy..."
          
          # Wait for health checks
          for i in {1..10}; do
            APP_HEALTH=$(docker inspect vitransfer-app --format='{{.State.Health.Status}}' 2>/dev/null || echo "starting")
            echo "Attempt $i: App health = $APP_HEALTH"
            if [[ "$APP_HEALTH" == "healthy" ]]; then
              break
            fi
            sleep 5
          done
          
          # Final health check
          APP_HEALTH=$(docker inspect vitransfer-app --format='{{.State.Health.Status}}')
          if [[ "$APP_HEALTH" != "healthy" ]]; then
            echo "[ERROR] Old version failed to start"
            docker logs vitransfer-app --tail 100
            exit 1
          fi
          echo "[OK] Old version is running"

      - name: Seed test data
        run: |
          echo "[SEED] Seeding test data..."
          
          # Login and get auth token
          echo "Logging in to get auth token..."
          LOGIN_RESPONSE=$(curl -s -X POST http://localhost:4321/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@test.local","password":"TestPassword123!"}')
          
          AUTH_TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"accessToken":"[^"]*"' | sed 's/"accessToken":"//;s/"$//')
          
          if [[ -z "$AUTH_TOKEN" ]]; then
            echo "[ERROR] Failed to get auth token"
            echo "$LOGIN_RESPONSE"
            exit 1
          fi
          
          # Create test project via API
          echo "Creating seed test project..."
          CREATE_PROJECT=$(curl -s -X POST http://localhost:4321/api/projects \
            -H "Authorization: Bearer $AUTH_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "CI Test Project",
              "description": "Pre-upgrade seed project",
              "recipientName": "Seed Client",
              "recipientEmail": "seed@test.local",
              "sharePassword": "SeedPass123",
              "authMode": "PASSWORD"
            }')
          
          if [[ "$CREATE_PROJECT" == *"error"* ]]; then
            echo "[ERROR] Failed to create seed project"
            echo "$CREATE_PROJECT"
            exit 1
          fi
          
          SEED_PROJECT_ID=$(echo "$CREATE_PROJECT" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"$//')
          echo "Seed project created with ID: $SEED_PROJECT_ID"
          echo "$SEED_PROJECT_ID" > /tmp/seed_project_id.txt
          
          # Get current data count
          BEFORE_PROJECTS=$(docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -t -c "SELECT COUNT(*) FROM \"Project\";" | tr -d ' ')
          BEFORE_USERS=$(docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -t -c "SELECT COUNT(*) FROM \"User\";" | tr -d ' ')
          
          echo "Before upgrade:"
          echo "  Projects: $BEFORE_PROJECTS"
          echo "  Users: $BEFORE_USERS"
          
          # Store counts for later verification
          echo "$BEFORE_PROJECTS" > /tmp/before_projects.txt
          echo "$BEFORE_USERS" > /tmp/before_users.txt
          echo "[OK] Test data seeded successfully"

      - name: Backup database
        run: |
          echo "[BACKUP] Creating database backup..."
          docker exec vitransfer-postgres pg_dump -U vitransfer vitransfer > /tmp/backup_before_upgrade.sql
          echo "[OK] Database backed up to /tmp/backup_before_upgrade.sql"

      - name: Stop old version
        run: |
          echo "[STOP] Stopping old version..."
          docker compose stop app worker
          docker compose rm -f app worker

      - name: Upgrade to new version
        run: |
          TO_VERSION="${{ steps.versions.outputs.to_version }}"
          echo "[UPGRADE] Upgrading to version $TO_VERSION..."
          
          # Restore new compose file
          mv docker-compose.yml.new docker-compose.yml
          
          # If specific version requested, update compose
          if [[ "$TO_VERSION" != "latest" ]]; then
            sed -i "s/image: crypt010\/vitransfer:latest/image: crypt010\/vitransfer:$TO_VERSION/g" docker-compose.yml
          fi
          
          # Pull new version
          docker compose pull app worker
          
          # Start new version (database and redis are still running)
          docker compose up -d app worker
          
          echo "[WAIT] Waiting for new version to be ready..."
          sleep 40

      - name: Verify upgrade succeeded
        run: |
          echo "Checking if new version is healthy..."
          
          # Wait for health checks
          for i in {1..10}; do
            APP_HEALTH=$(docker inspect vitransfer-app --format='{{.State.Health.Status}}' 2>/dev/null || echo "starting")
            echo "Attempt $i: App health = $APP_HEALTH"
            if [[ "$APP_HEALTH" == "healthy" ]]; then
              break
            fi
            sleep 5
          done
          
          # Final health check
          APP_HEALTH=$(docker inspect vitransfer-app --format='{{.State.Health.Status}}')
          if [[ "$APP_HEALTH" != "healthy" ]]; then
            echo "[ERROR] New version failed to start"
            docker logs vitransfer-app --tail 100
            exit 1
          fi
          echo "[OK] New version is running"

      - name: Verify migrations ran
        run: |
          echo "Checking if migrations ran successfully..."
          docker logs vitransfer-app 2>&1 | grep -i "migration" || true
          
          # Check for migration errors
          MIGRATION_ERRORS=$(docker logs vitransfer-app 2>&1 | grep -i "migration.*error" || echo "")
          if [[ -n "$MIGRATION_ERRORS" ]]; then
            echo "[ERROR] Migration errors detected:"
            echo "$MIGRATION_ERRORS"
            exit 1
          fi
          echo "[OK] No migration errors detected"

      - name: Verify data integrity
        run: |
          echo "[VERIFY] Verifying data integrity after upgrade..."
          
          # Get counts after upgrade
          AFTER_PROJECTS=$(docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -t -c "SELECT COUNT(*) FROM \"Project\";" | tr -d ' ')
          AFTER_USERS=$(docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -t -c "SELECT COUNT(*) FROM \"User\";" | tr -d ' ')
          
          BEFORE_PROJECTS=$(cat /tmp/before_projects.txt)
          BEFORE_USERS=$(cat /tmp/before_users.txt)
          
          echo "After upgrade:"
          echo "  Projects: $AFTER_PROJECTS (was $BEFORE_PROJECTS)"
          echo "  Users: $AFTER_USERS (was $BEFORE_USERS)"
          
          # Verify counts match
          if [[ "$AFTER_PROJECTS" != "$BEFORE_PROJECTS" ]]; then
            echo "[ERROR] Project count mismatch!"
            exit 1
          fi
          
          if [[ "$AFTER_USERS" != "$BEFORE_USERS" ]]; then
            echo "[ERROR] User count mismatch!"
            exit 1
          fi
          
          echo "[OK] Data integrity verified - all counts match"

      - name: Test functionality after upgrade
        run: |
          echo "[TEST] Testing functionality after upgrade..."
          
          # Test health endpoint
          RESPONSE=$(curl -s http://localhost:4321/api/health)
          if [[ "$RESPONSE" != *"ok"* ]]; then
            echo "[ERROR] Health check failed"
            exit 1
          fi
          echo "[OK] Health check passed"
          
          # Test login and save token
          LOGIN_RESPONSE=$(curl -s -X POST http://localhost:4321/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@test.local","password":"TestPassword123!"}')
          if [[ "$LOGIN_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Login failed after upgrade"
            echo "$LOGIN_RESPONSE"
            exit 1
          fi
          echo "[OK] Login still works"
          
          # Extract accessToken from the tokens object in the response
          AUTH_TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"accessToken":"[^"]*"' | head -1 | sed 's/"accessToken":"//;s/"$//')
          if [[ -z "$AUTH_TOKEN" ]]; then
            echo "[ERROR] Failed to extract access token"
            exit 1
          fi
          echo "$AUTH_TOKEN" > /tmp/auth_token.txt

      - name: Test API endpoints after upgrade
        run: |
          echo "[TEST] Testing API endpoints after upgrade..."
          AUTH_TOKEN=$(cat /tmp/auth_token.txt)
          
          # Test session endpoint
          echo "Testing session endpoint..."
          SESSION_RESPONSE=$(curl -s http://localhost:4321/api/auth/session \
            -H "Authorization: Bearer $AUTH_TOKEN")
          echo "Session response: $SESSION_RESPONSE"
          if [[ "$SESSION_RESPONSE" != *"admin@test.local"* ]] || [[ "$SESSION_RESPONSE" == *'"authenticated":false'* ]]; then
            echo "[ERROR] Session endpoint failed"
            echo "Full session response: $SESSION_RESPONSE"
            exit 1
          fi
          echo "[OK] Session endpoint working"
          
          # Test projects list endpoint
          echo "Testing projects list..."
          PROJECTS_RESPONSE=$(curl -s http://localhost:4321/api/projects \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$PROJECTS_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Projects endpoint failed"
            echo "$PROJECTS_RESPONSE"
            exit 1
          fi
          echo "[OK] Projects endpoint working"
          
          # Verify seeded projects are still there
          if [[ "$PROJECTS_RESPONSE" != *"CI Test Project"* ]]; then
            echo "[ERROR] Seeded project not found after upgrade!"
            exit 1
          fi
          echo "[OK] Seeded projects preserved"
          
          # Test users list endpoint
          echo "Testing users list..."
          USERS_RESPONSE=$(curl -s http://localhost:4321/api/users \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$USERS_RESPONSE" == *"error"* ]] || [[ "$USERS_RESPONSE" != *"admin@test.local"* ]]; then
            echo "[ERROR] Users endpoint failed"
            echo "$USERS_RESPONSE"
            exit 1
          fi
          echo "[OK] Users endpoint working"
          
          # Test settings endpoint
          echo "Testing settings endpoint..."
          SETTINGS_RESPONSE=$(curl -s http://localhost:4321/api/settings \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$SETTINGS_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Settings endpoint failed"
            echo "$SETTINGS_RESPONSE"
            exit 1
          fi
          echo "[OK] Settings endpoint working"
          
          # Test analytics endpoint
          echo "Testing analytics endpoint..."
          ANALYTICS_RESPONSE=$(curl -s http://localhost:4321/api/analytics \
            -H "Authorization: Bearer $AUTH_TOKEN")
          if [[ "$ANALYTICS_RESPONSE" == *"error"* ]]; then
            echo "[ERROR] Analytics endpoint failed"
            echo "$ANALYTICS_RESPONSE"
            exit 1
          fi
          echo "[OK] Analytics endpoint working"

      - name: Test creating new project after upgrade
        run: |
          echo "[TEST] Testing project creation after upgrade..."
          AUTH_TOKEN=$(cat /tmp/auth_token.txt)
          
          CREATE_PROJECT=$(curl -s -X POST http://localhost:4321/api/projects \
            -H "Authorization: Bearer $AUTH_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "Post-Upgrade Test Project",
              "description": "Created after upgrade",
              "recipientName": "Upgrade Test Client",
              "recipientEmail": "upgrade@test.local",
              "sharePassword": "UpgradePass456",
              "authMode": "PASSWORD"
            }')
          
          if [[ "$CREATE_PROJECT" == *"error"* ]]; then
            echo "[ERROR] Project creation failed after upgrade"
            echo "$CREATE_PROJECT"
            exit 1
          fi
          
          PROJECT_ID=$(echo "$CREATE_PROJECT" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"$//')
          echo "New project created after upgrade with ID: $PROJECT_ID"
          echo "[OK] Project creation still works after upgrade"

      - name: Test worker after upgrade
        run: |
          echo "[TEST] Testing worker after upgrade..."
          
          WORKER_LOGS=$(docker logs vitransfer-worker 2>&1)
          if [[ "$WORKER_LOGS" != *"Video processing worker started"* ]]; then
            echo "[ERROR] Worker did not start properly after upgrade"
            exit 1
          fi
          echo "[OK] Worker operational"

      - name: Compare database schemas
        run: |
          echo "[SCHEMA] Comparing database schemas..."
          
          # Get current schema
          docker exec vitransfer-postgres pg_dump -U vitransfer --schema-only vitransfer > /tmp/schema_after_upgrade.sql
          
          echo "Schema dump created. Tables present:"
          docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -c "\dt"

      - name: Generate upgrade summary
        if: always()
        run: |
          # Get data counts
          PROJECTS_BEFORE=$(cat /tmp/before_projects.txt 2>/dev/null || echo "0")
          USERS_BEFORE=$(cat /tmp/before_users.txt 2>/dev/null || echo "0")
          
          PROJECTS_AFTER=$(docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -t -c "SELECT COUNT(*) FROM \"Project\";" 2>/dev/null | tr -d ' ' || echo "0")
          USERS_AFTER=$(docker exec vitransfer-postgres psql -U vitransfer -d vitransfer -t -c "SELECT COUNT(*) FROM \"User\";" 2>/dev/null | tr -d ' ' || echo "0")
          
          # Determine data integrity status
          if [[ "$PROJECTS_BEFORE" == "$PROJECTS_AFTER" ]] && [[ "$USERS_BEFORE" == "$USERS_AFTER" ]]; then
            DATA_INTEGRITY="[OK] All data preserved"
          else
            DATA_INTEGRITY="[WARN] Data count mismatch detected"
          fi
          
          # Pre-calculate status for table rows
          if [[ "$PROJECTS_BEFORE" == "$PROJECTS_AFTER" ]]; then
            PROJECTS_STATUS="[OK]"
          else
            PROJECTS_STATUS="[ERROR]"
          fi
          
          if [[ "$USERS_BEFORE" == "$USERS_AFTER" ]]; then
            USERS_STATUS="[OK]"
          else
            USERS_STATUS="[ERROR]"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Production Upgrade Test Results
          
          ## Upgrade Path
          - **From Version**: \`${{ steps.versions.outputs.from_version }}\`
          - **To Version**: \`${{ steps.versions.outputs.to_version }}\`
          - **PostgreSQL**: \`${{ steps.versions.outputs.postgres_version }}\`
          - **Redis**: \`${{ steps.versions.outputs.redis_version }}\`
          
          ## Data Integrity Check
          
          | Resource | Before Upgrade | After Upgrade | Status |
          |----------|----------------|---------------|--------|
          | Projects | ${PROJECTS_BEFORE} | ${PROJECTS_AFTER} | ${PROJECTS_STATUS} |
          | Users | ${USERS_BEFORE} | ${USERS_AFTER} | ${USERS_STATUS} |
          
          **Overall Data Integrity**: ${DATA_INTEGRITY}
          
          ## Test Results
          
          | Test | Status |
          |------|--------|
          | Initial Deployment | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Data Seeding | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Database Backup | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Version Upgrade | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Database Migrations | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Data Verification | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | API Health Endpoint | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Admin Login | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Session API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Projects API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Seeded Data Preserved | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Users API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Settings API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Analytics API | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Project Creation After Upgrade | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          | Worker Service | ${{ job.status == 'success' && '[OK] Passed' || '[ERROR] Failed' }} |
          EOF

      - name: Show upgrade logs on failure
        if: failure()
        run: |
          echo "=== Application Logs (Last 200 lines) ==="
          docker logs vitransfer-app --tail 200
          echo ""
          echo "=== Worker Logs ==="
          docker logs vitransfer-worker --tail 100
          echo ""
          echo "=== PostgreSQL Logs ==="
          docker logs vitransfer-postgres --tail 50
          echo ""
          echo "=== Database Backup (First 50 lines) ==="
          head -n 50 /tmp/backup_before_upgrade.sql

      - name: Upload backup on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: database-backup-before-upgrade
          path: /tmp/backup_before_upgrade.sql
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
          rm -f .env cookies.txt
          rm -f /tmp/before_projects.txt /tmp/before_users.txt
          rm -f /tmp/backup_before_upgrade.sql /tmp/schema_after_upgrade.sql
