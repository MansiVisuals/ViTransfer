'use client'

import { useState, useRef, useEffect } from 'react'
import { Video, ProjectStatus } from '@prisma/client'
import { Button } from './ui/button'
import { Download, Info, CheckCircle2 } from 'lucide-react'
import { formatTimestamp, formatFileSize } from '@/lib/utils'
import { useRouter } from 'next/navigation'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from './ui/dialog'

interface VideoPlayerProps {
  videos: Video[]
  projectId: string
  projectStatus: ProjectStatus
  defaultQuality?: '720p' | '1080p' // Default quality from settings
  onApprove?: () => void // Optional approval callback
  projectTitle?: string
  projectDescription?: string
  clientName?: string
  currentRevision?: number
  maxRevisions?: number
  enableRevisions?: boolean
  isPasswordProtected?: boolean
  watermarkEnabled?: boolean
  isAdmin?: boolean // Admin users can see all versions (default: false for clients)
  activeVideoName?: string // The video group name (for maintaining selection after reload)
  initialSeekTime?: number | null // Initial timestamp to seek to (from URL params)
  initialVideoIndex?: number // Initial video index to select (from URL params)
}

export default function VideoPlayer({
  videos,
  projectId,
  projectStatus,
  defaultQuality = '720p',
  onApprove,
  projectTitle,
  projectDescription,
  clientName,
  currentRevision,
  maxRevisions,
  enableRevisions,
  isPasswordProtected,
  watermarkEnabled = true,
  isAdmin = false, // Default to false (client view)
  activeVideoName,
  initialSeekTime = null,
  initialVideoIndex = 0
}: VideoPlayerProps) {
  const router = useRouter()
  const [selectedVideoIndex, setSelectedVideoIndex] = useState(initialVideoIndex)
  const [currentTime, setCurrentTime] = useState(0)
  const [videoUrl, setVideoUrl] = useState<string>('')
  const [showInfoDialog, setShowInfoDialog] = useState(false)
  const [showApprovalConfirm, setShowApprovalConfirm] = useState(false)
  const [loading, setLoading] = useState(false)

  const videoRef = useRef<HTMLVideoElement>(null)
  const hasInitiallySeenRef = useRef(false) // Track if initial seek already happened

  // Filter videos for clients: if ANY video is approved, only show approved videos
  // Admins always see all videos
  const hasAnyApprovedVideo = videos.some((v: any) => v.approved === true)
  const displayVideos = (isAdmin || !hasAnyApprovedVideo)
    ? videos
    : videos.filter((v: any) => v.approved === true)

  // Safety check: ensure index is valid
  const safeIndex = Math.min(selectedVideoIndex, displayVideos.length - 1)
  const selectedVideo = displayVideos[safeIndex >= 0 ? safeIndex : 0]

  // Safety check: ensure selectedVideo exists before accessing properties
  const isVideoApproved = selectedVideo ? (selectedVideo as any).approved === true : false
  const isProjectApproved = projectStatus === 'APPROVED' || projectStatus === 'SHARE_ONLY'

  // Load video URL with optimization
  useEffect(() => {
    async function loadVideoUrl() {
      try {
        // Safety check: ensure selectedVideo exists
        if (!selectedVideo) {
          return
        }

        // Use token-based URLs from the video object
        // These are generated by the share API with secure tokens
        // Respect the default quality setting from admin
        let url: string | undefined

        if (defaultQuality === '1080p') {
          // Prefer 1080p, fallback to 720p
          url = (selectedVideo as any).streamUrl1080p || (selectedVideo as any).streamUrl720p
        } else {
          // Prefer 720p, fallback to 1080p
          url = (selectedVideo as any).streamUrl720p || (selectedVideo as any).streamUrl1080p
        }

        if (url) {
          setVideoUrl(url)

          // Reset player state
          setCurrentTime(0)

          // Preload video for smooth playback after URL is set
          if (videoRef.current) {
            videoRef.current.load()
          }
        }
      } catch (error) {
        console.error('Error loading video:', error)
      }
    }

    loadVideoUrl()
  }, [selectedVideo, defaultQuality])

  // Handle initial seek from URL parameters (only once on mount)
  useEffect(() => {
    if (initialSeekTime !== null && videoRef.current && videoUrl && !hasInitiallySeenRef.current) {
      const handleLoadedMetadata = () => {
        if (videoRef.current && initialSeekTime !== null) {
          // Ensure timestamp is within video duration
          const duration = videoRef.current.duration
          const seekTime = Math.min(initialSeekTime, duration)

          videoRef.current.currentTime = seekTime
          videoRef.current.play().catch(() => {}) // Auto-play after seeking (ignore errors)

          // Mark that we've done the initial seek
          hasInitiallySeenRef.current = true
        }
      }

      // If metadata already loaded, seek immediately
      if (videoRef.current.readyState >= 1) {
        handleLoadedMetadata()
      } else {
        // Otherwise wait for metadata to load
        videoRef.current.addEventListener('loadedmetadata', handleLoadedMetadata, { once: true })
      }

      return () => {
        videoRef.current?.removeEventListener('loadedmetadata', handleLoadedMetadata)
      }
    }
  }, [initialSeekTime, videoUrl])

  // Optimize video element for smooth playback
  useEffect(() => {
    const video = videoRef.current
    if (!video) return

    // Enable hardware acceleration hints
    video.setAttribute('playsinline', 'true')

    // Optimize buffering for smooth playback and scrubbing
    const optimizePlayback = () => {
      // Force browser to buffer more for smoother scrubbing
      if (video.buffered.length > 0) {
        const bufferedEnd = video.buffered.end(video.buffered.length - 1)
        const duration = video.duration

        // If less than 30% buffered, pause briefly to buffer more
        if (bufferedEnd / duration < 0.3 && !video.paused) {
          // Browser will auto-buffer ahead
        }
      }
    }

    video.addEventListener('progress', optimizePlayback)
    video.addEventListener('canplay', optimizePlayback)

    return () => {
      video.removeEventListener('progress', optimizePlayback)
      video.removeEventListener('canplay', optimizePlayback)
    }
  }, [videoUrl])

  // Expose current time for CommentSection
  useEffect(() => {
    const handleGetCurrentTime = (e: CustomEvent) => {
      if (e.detail.callback) {
        e.detail.callback(currentTime, selectedVideo.id)
      }
    }

    window.addEventListener('getCurrentTime' as any, handleGetCurrentTime as EventListener)
    return () => {
      window.removeEventListener('getCurrentTime' as any, handleGetCurrentTime as EventListener)
    }
  }, [currentTime, selectedVideo.id])

  // Expose selected video ID for approval
  useEffect(() => {
    const handleGetSelectedVideoId = (e: CustomEvent) => {
      if (e.detail.callback) {
        e.detail.callback(selectedVideo.id)
      }
    }

    window.addEventListener('getSelectedVideoId' as any, handleGetSelectedVideoId as EventListener)
    return () => {
      window.removeEventListener('getSelectedVideoId' as any, handleGetSelectedVideoId as EventListener)
    }
  }, [selectedVideo.id])

  // Handle seek to timestamp requests from comments
  useEffect(() => {
    const handleSeekToTime = (e: CustomEvent) => {
      const { timestamp, videoId, videoVersion } = e.detail

      // If videoId is specified and different from current, try to switch to it
      if (videoId && videoId !== selectedVideo.id) {
        const targetVideoIndex = displayVideos.findIndex(v => v.id === videoId)
        if (targetVideoIndex !== -1) {
          setSelectedVideoIndex(targetVideoIndex)
          // Wait for video to load before seeking
          setTimeout(() => {
            if (videoRef.current) {
              videoRef.current.currentTime = timestamp
              videoRef.current.play().catch(() => {}) // Auto-play after seeking (ignore errors)
            }
          }, 500)
          return
        }
      }

      // Same video - just seek
      if (videoRef.current) {
        videoRef.current.currentTime = timestamp
        videoRef.current.play().catch(() => {}) // Auto-play after seeking (ignore errors)
      }
    }

    window.addEventListener('seekToTime' as any, handleSeekToTime as EventListener)
    return () => {
      window.removeEventListener('seekToTime' as any, handleSeekToTime as EventListener)
    }
  }, [selectedVideo.id, displayVideos])

  const handleTimeUpdate = () => {
    if (videoRef.current) {
      setCurrentTime(videoRef.current.currentTime)
    }
  }

  const handleDownload = () => {
    // Use secure token-based download URL
    const downloadUrl = (selectedVideo as any).downloadUrl
    if (downloadUrl) {
      window.open(downloadUrl, '_blank')
    } else {
      alert('Download is only available for approved projects')
    }
  }

  const handleApprove = async () => {
    setLoading(true)

    try {
      const response = await fetch(`/api/projects/${projectId}/approve`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          selectedVideoId: selectedVideo.id,
        }),
        credentials: 'include', // Include cookies for authentication
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to approve project')
      }

      // Store the current video group name in sessionStorage to restore after reload
      if (activeVideoName) {
        sessionStorage.setItem('approvedVideoName', activeVideoName)
      }

      // Call the optional callback if provided (for parent component updates)
      if (onApprove) {
        await onApprove()
      }

      // Reload the page to show updated state
      window.location.reload()
    } catch (error) {
      alert('Failed to approve project')
    } finally {
      setLoading(false)
    }
  }

  // Safety check: if no videos available, show message
  if (!selectedVideo || displayVideos.length === 0) {
    return (
      <div className="p-8 text-center text-muted-foreground">
        No videos available
      </div>
    )
  }

  // Get display label - if video approved, show "Final Version"
  const displayLabel = isVideoApproved ? 'Final Version' : selectedVideo.versionLabel

  return (
    <div className="space-y-4">
      {/* Version Selector - Only show if there are multiple versions to choose from */}
      {displayVideos.length > 1 && (
        <div className="flex gap-3 overflow-x-auto pb-2">
          {displayVideos.map((video, index) => {
            const videoApproved = (video as any).approved === true
            return (
              <Button
                key={video.id}
                onClick={() => setSelectedVideoIndex(index)}
                variant={selectedVideoIndex === index ? 'default' : 'outline'}
                className="whitespace-nowrap relative"
              >
                {videoApproved && (
                  <CheckCircle2 className="w-4 h-4 mr-2 text-success" />
                )}
                {videoApproved ? 'Final Version' : video.versionLabel}
              </Button>
            )
          })}
        </div>
      )}

      {/* Video Player */}
      <div className="relative bg-background rounded-lg overflow-hidden aspect-video">
        {videoUrl ? (
          <video
            ref={videoRef}
            src={videoUrl}
            className="w-full h-full"
            onTimeUpdate={handleTimeUpdate}
            crossOrigin="anonymous"
            controls
            playsInline
            preload="auto"
            style={{
              objectFit: 'contain',
              backgroundColor: '#000',
            }}
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-card-foreground">
            Loading video...
          </div>
        )}
      </div>

      {/* Video Info */}
      <div className="bg-card rounded-lg p-4 text-card-foreground">
        <div className="flex flex-col sm:flex-row items-start sm:items-start justify-between gap-3 mb-3">
          <h3 className="font-medium">{displayLabel}</h3>
          <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
            {/* Info Dialog Button */}
            <Dialog open={showInfoDialog} onOpenChange={setShowInfoDialog}>
              <DialogTrigger asChild>
                <Button variant="default" size="sm" className="w-full sm:w-auto">
                  <Info className="w-4 h-4 mr-2" />
                  Info
                </Button>
              </DialogTrigger>
              <DialogContent className="bg-card border-border text-card-foreground max-w-[95vw] sm:max-w-md">
                <DialogHeader>
                  <DialogTitle>Video Information</DialogTitle>
                  <DialogDescription className="text-muted-foreground">
                    Detailed metadata for this video
                  </DialogDescription>
                </DialogHeader>
                <div className="space-y-3 text-xs sm:text-sm">
                  <div className="flex flex-col gap-1">
                    <span className="text-muted-foreground">Filename:</span>
                    <span className="font-medium break-all text-xs sm:text-sm">{selectedVideo.originalFileName}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Resolution:</span>
                    <span className="font-medium">{selectedVideo.width}x{selectedVideo.height}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Codec:</span>
                    <span className="font-medium">{selectedVideo.codec || 'N/A'}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Duration:</span>
                    <span className="font-medium">{formatTimestamp(selectedVideo.duration)}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">FPS:</span>
                    <span className="font-medium">{selectedVideo.fps ? selectedVideo.fps.toFixed(2) : 'N/A'}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">File Size:</span>
                    <span className="font-medium">{formatFileSize(Number(selectedVideo.originalFileSize))}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Upload Date:</span>
                    <span className="font-medium">{new Date(selectedVideo.createdAt).toLocaleDateString()}</span>
                  </div>
                  <div className="flex flex-col sm:flex-row sm:justify-between gap-1">
                    <span className="text-muted-foreground">Status:</span>
                    <span className="font-medium break-words">{isVideoApproved ? 'Approved - Original Quality' : 'Preview - Watermarked'}</span>
                  </div>
                </div>
              </DialogContent>
            </Dialog>

            {/* Download Button - Only show when video is approved */}
            {isVideoApproved && (
              <Button onClick={handleDownload} variant="default" size="sm" className="w-full sm:w-auto">
                <Download className="w-4 h-4 mr-2" />
                Download
              </Button>
            )}
          </div>
        </div>

        {/* Project Info & Approval Box */}
        <div className={`rounded-lg p-4 space-y-3 ${!isVideoApproved ? 'bg-accent/50 border border-primary/20' : 'bg-accent/50 border border-border'}`}>
          {/* Project Information */}
          {projectTitle && (
            <div className="space-y-2">
              <h2 className="text-lg font-bold text-foreground">{projectTitle}</h2>
              {projectDescription && (
                <p className="text-sm text-muted-foreground">{projectDescription}</p>
              )}
              <div className="flex flex-wrap gap-3 text-sm">
                {clientName && (
                  <span className="text-muted-foreground">
                    For: <span className="font-medium text-foreground">
                      {isPasswordProtected ? clientName : 'Client'}
                    </span>
                  </span>
                )}
                {!isVideoApproved && enableRevisions && (
                  <span className="text-muted-foreground">
                    Revision: <span className="font-medium text-foreground">
                      {currentRevision}/{maxRevisions}
                    </span>
                  </span>
                )}
              </div>
            </div>
          )}

          {/* Note & Approval Section (only if video not approved) */}
          {!isVideoApproved && (
            <>
              <div className="text-sm text-muted-foreground pt-2 border-t border-border">
                <span className="font-medium text-foreground">Note:</span> This is a preview quality version
                {watermarkEnabled && ' with watermark'}. The final version will be available in the highest resolution after approval.
              </div>

              <div className="pt-2 border-t border-border">
                {!showApprovalConfirm ? (
                  <div className="space-y-2">
                    <p className="text-sm text-muted-foreground">
                      Ready to approve this video?
                    </p>
                    <Button
                      onClick={() => setShowApprovalConfirm(true)}
                      variant="success"
                      size="default"
                      className="w-full"
                    >
                      Approve this video as final
                    </Button>
                  </div>
                ) : (
                  <div className="space-y-4 bg-primary/10 border-2 border-primary rounded-lg p-4">
                    <div className="text-center space-y-2">
                      <p className="text-base text-foreground font-bold">
                        Approve this video?
                      </p>
                      <p className="text-sm text-muted-foreground">
                        Video: <span className="font-semibold text-foreground">"{(selectedVideo as any).name}"</span>
                      </p>
                      <p className="text-sm text-muted-foreground">
                        Version: <span className="font-semibold text-foreground">{selectedVideo.versionLabel}</span>
                      </p>
                    </div>

                    <div className="flex gap-2">
                      <Button
                        onClick={handleApprove}
                        disabled={loading}
                        variant="success"
                        size="default"
                        className="flex-1 font-semibold"
                      >
                        {loading ? 'Approving...' : 'Yes, Approve This Video'}
                      </Button>
                      <Button
                        onClick={() => setShowApprovalConfirm(false)}
                        variant="outline"
                        disabled={loading}
                        size="default"
                      >
                        Cancel
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            </>
          )}

          {/* Approved Status */}
          {isVideoApproved && (
            <div className="flex items-center gap-2 text-sm text-success pt-2 border-t border-border">
              <CheckCircle2 className="w-4 h-4" />
              <span className="font-medium">This video is approved - Download available</span>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}